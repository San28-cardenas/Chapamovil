
#pragma config BWRP = WRPROTECT_OFF
#pragma config SWRP = WRPROTECT_OFF
#pragma config GWRP = OFF
#pragma config GSS = OFF
#pragma config FNOSC = FRC        // Oscilador interno FRC ~7.37 MHz
#pragma config POSCMD = NONE
#pragma config FWDTEN = OFF
#pragma config ICS = PGD3

#define FCY 7370000UL
#include "xc.h"
#include <libpic30.h>
#include "p33FJ128MC802.h"

// Servo límites en cuentas de Timer2
#define SERVO_MIN  461
#define SERVO_MAX  921

volatile unsigned int adc_value = 0;

void configurar_pines(void);
void configurar_adc(void);
void configurar_pwm_servo(void);
void actualizar_servo(void);

int main(void)
{
    configurar_pines();
    configurar_adc();
    configurar_pwm_servo();

    while(1)
    {
        // Iniciar conversión ADC en AN0
        AD1CHS0bits.CH0SA = 0;      // Canal AN0
        AD1CON1bits.SAMP = 1;       // Inicia muestreo
        __delay_us(10);
        AD1CON1bits.SAMP = 0;       // Termina muestreo, inicia conversión
        while(!AD1CON1bits.DONE);   // Espera fin de conversión
        adc_value = ADC1BUF0;       // Lee resultado

        actualizar_servo();
        __delay_ms(50);
    }
}

void configurar_pines(void)
{
    // AN0 como entrada analógica
    AD1PCFGL = 0xFFFE; // AN0 analógico
    TRISA = 0x0001;    // RA0 entrada

    // PWM en RP12 (RB12)
    TRISBbits.TRISB12 = 0;
    __builtin_write_OSCCONL(OSCCON & 0xBF);
    RPOR6bits.RP12R = 18; // OC1
    __builtin_write_OSCCONL(OSCCON | 0x40);
}

void configurar_adc(void)
{
    AD1CON1 = 0x0000;
    AD1CON2 = 0x0000;
    AD1CON3 = 0x0000;
    AD1CSSL = 0x0000;
    AD1CHS0 = 0x0000;

    AD1CON1bits.FORM = 0;   // Entero
    AD1CON1bits.SSRC = 7;   // Auto-convertir
    AD1CON1bits.ASAM = 0;   // Muestreo manual
    AD1CON2bits.VCFG = 0;   // Vref+ = AVdd, Vref- = AVss
    AD1CON3bits.SAMC = 31;  // Tiempo de muestreo
    AD1CON3bits.ADCS = 63;  // TAD
    AD1CON1bits.ADON = 1;   // Habilitar ADC
}

void configurar_pwm_servo(void)
{
    T2CONbits.TON = 0;
    T2CONbits.TCKPS = 1; // Prescaler 1:8
    PR2 = 9215;          // 20 ms
    TMR2 = 0;
    T2CONbits.TON = 1;

    OC1CONbits.OCM = 0;
    OC1CONbits.OCTSEL = 0;
    OC1R = SERVO_MIN + (SERVO_MAX - SERVO_MIN)/2;
    OC1RS = OC1R;
    OC1CONbits.OCM = 6;
}

void actualizar_servo(void)
{
    unsigned long pulso = SERVO_MIN +
        ((unsigned long)adc_value * (SERVO_MAX - SERVO_MIN)) / 1023;
    OC1RS = pulso;
}
